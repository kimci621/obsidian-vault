
Представиться:  
  Меня зовут Амир, на данный момент оперирую разработкой фронтенда в huntlee, это ats система для автоматизации работы рекрутеров и их заказчиков. Если вкратце, то система позволяет вести кандидата по этапам вакансии, соблюдая заранее настроенные параметры. Иметь свою базу кандидатов, вести эту базу и тп. Имеется тарифная сетка и уровни доступа.  
  
Рассказать про huntlee с технической стороны:

Текущий основной стек typescript, vue 3, composition api, setup синтаксис, nuxt 3, ui библиотека element plus, библиотека для форм vueform, tailwind для стилей и стандартный набор для код линтинга (prettier, eslint, commitlint), runtime менеджер bun.  
В основном очень много работы с формами, в некоторых случаях без прямого участия дизайнера. Разделения на уровни доступа, много асинхронный данных которые должны обновляться во всех частях приложения. Команда на данный момент 2 фронта, 3 бэкенда, аналитик, дизайнер, тестерощик и техлид.

  

Узнать про прошлый опыт:  
Где и как учился

Где работал

Состав команды

Стек с каким работал  
Любимый стек 

  

Задать технические вопросы:

Что такое AJAX? -

Ответ:

(«Асинхронный JavaScript и XML». Смысл здесь — в асинхронности действий браузера и сервера)

------------------------------------------------------------------

Как взаимодействует клиент и сервер в большинстве приложений 

Ответ:

(по http, api, Запросы (HTTP Requests) — сообщения, которые отправляются клиентом на сервер, чтобы вызвать выполнение некоторых действий. Зачастую для получения доступа к определенному ресурсу. Основой запроса является HTTP-заголовок. Ответы (HTTP Responses) — сообщения, которые сервер отправляет в ответ на клиентский запрос.)

------------------------------------------------------------------

Используешь ли Flexbox/Grid layout? Расскажи про каждый из них и с чем больше работал

------------------------------------------------------------------

Что такое доступная вёрстка? Зачем она нужна?

Ответ:

(Доступность — это практика, позволяющая использовать ваши сайты как можно большему числу людей. В том числе людям с ограниченными возможностями и устройствам без мыши)

------------------------------------------------------------------

Что такое семантическая вёрстка? Зачем нужна?

Ответ:

1. **Доступность**: Семантическая вёрстка помогает сделать веб-страницы более доступными для людей с ограниченными возможностями. Например, скрин-ридеры могут использовать семантические теги для передачи смысла содержимого страницы.

2. **Поисковая оптимизация**: Семантическая вёрстка помогает поисковым системам понимать содержимое страницы и улучшает позицию страницы в поисковых результатах.

3. **Упрощение поддержки**: Семантическая вёрстка упрощает поддержку и обновление веб-страниц, поскольку она позволяет легко изменять структуру и дизайн страницы без изменения содержимого.

4. **Улучшение читаемости**: Семантическая вёрстка улучшает читаемость кода, поскольку она позволяет разработчикам легко понимать структуру и содержимое страницы.

------------------------------------------------------------------

Был ли опыт с анимациями? css или js, расскажи поверхностно, сложно ли было освоить и чем именно работал

Ответ: -

------------------------------------------------------------------

Почему JS называют языком с динамической типизацией?

Ответ:

JS называют языком с динамической типизацией, потому что тип переменной определяется во время выполнения программы, а не во время компиляции. Это означает, что переменная может хранить значения разных типов данных в разное время.

------------------------------------------------------------------

Расскажи как ты понимаешь прототипное наследование?  
Ответ:

Прототипное наследование в JavaScript - это механизм, который позволяет объектам наследовать свойства и методы от других объектов. Это основной способ организации наследования в JavaScript.

  

В JavaScript, каждый объект имеет свойство `prototype`, которое ссылается на другой объект, который является его прототипом. Когда мы пытаемся получить доступ к свойству или методу объекта, JavaScript сначала проверяет, есть ли оно в самом объекте. Если нет, то он начинает искать его в прототипе объекта, а затем в прототипе прототипа и так далее, пока не найдет его или не дойдет до конца цепочки прототипов.

  

Прототипное наследование можно представить как цепочку объектов, где каждый объект наследует свойства и методы от своего прототипа. Эта цепочка называется "цепочкой прототипов".

------------------------------------------------------------------

Чем передача данных по ссылке отличается от передачи данных по значению?

Ответ:  
При передаче данных по значению, переменная или функция получает копию значения, которое было передано. Это означает, что изменения, внесенные в переменную или функцию, не влияют на исходное значение.

------------------------------------------------------------------

Чем асинхронный код отличается от синхронного?

Ответ: -

------------------------------------------------------------------

Что такое замыкание?

Ответ: 

Замыкание (closure) в JavaScript - это функция, которая имеет доступ к своей внешней области видимости, даже после того, как внешняя функция завершила свою работу. Это означает, что замыкание может использовать переменные и функции из внешней области видимости, даже если они больше не доступны в текущей области видимости.

  

Замыкание создается, когда функция возвращает другую функцию, которая имеет доступ к переменным и функциям внешней области видимости. Это позволяет создавать функции, которые могут запоминать свое состояние и использовать его в будущем.

------------------------------------------------------------------

Чем отличается оператор равенства(==) от строго равенства(===)?

Ответ: -

------------------------------------------------------------------

Расскажи как работают Promise? И про async/await-конструкции

Ответ: -

------------------------------------------------------------------

Чем особенна стрелочная функция?

Ответ: 

1. Короткая запись: Стрелочная функция записывается в более краткой форме, чем традиционная функция. Это делает код более компактным и читабельным.

2. Нет ключевого слова function: Стрелочная функция не требует ключевого слова function для ее объявления.

3. Нет собственного контекста: Стрелочная функция не имеет собственного контекста (this), она наследует контекст родительской функции или глобального объекта.

4. Нет собственного arguments: Стрелочная функция не имеет собственного объекта arguments, она наследует объект arguments родительской функции.

5. Нет поддержки yield: Стрелочная функция не поддерживает ключевое слово yield, которое используется в генераторах.

6. Нет поддержки super: Стрелочная функция не поддерживает ключевое слово super, которое используется в классах для обращения к родительскому классу.

7. Нет поддержки new.target: Стрелочная функция не поддерживает ключевое слово new.target, которое используется для определения, была ли функция вызвана с ключевым словом new.

------------------------------------------------------------------

Сколько работаешь со Vue?

Ответ: -

------------------------------------------------------------------

Знаешь на чём написан механизм computed-свойств?

Ответ:

Механизм Vue 3 computed свойств написан на основе Proxy и реактивных переменных.

В Vue 3, computed свойства реализованы с помощью Proxy, который позволяет отслеживать изменения в реактивных переменных и автоматически обновлять вычисляемые свойства.

------------------------------------------------------------------

За счёт чего vue-router позволяет переходить по страницам без перезагрузки, что за магия сокрыта внутри?

Ответ:

Vue Router использует технологию HTML5 History API для перехода по страницам без перезагрузки. Эта технология позволяет изменять URL-адрес страницы без перезагрузки страницы.

  

Когда вы переходите по страницам с помощью Vue Router, он использует метод pushState или replaceState из HTML5 History API для изменения URL-адреса страницы. Этот метод позволяет изменять URL-адрес страницы без перезагрузки страницы.

------------------------------------------------------------------

Работал с серверным рендерингом (SSR)? Опиши кратко его суть, плюсы и минусы, предназначение?

Ответ:

SSR - это технология, которая позволяет серверу отрисовывать веб-страницы на стороне сервера, а не на стороне клиента. Это означает, что сервер генерирует HTML-код страницы и отправляет его клиенту, который затем отображает страницу в браузере.

  

Плюсы SSR

  

1. Улучшенная производительность: Поскольку сервер генерирует HTML-код страницы, клиент не нужно тратить время на отрисовку страницы.

2. Лучшая индексация поисковых систем: Поскольку сервер генерирует HTML-код страницы, поисковые системы могут проиндексировать страницу более эффективно.

3. Улучшенная совместимость с устройствами: Поскольку сервер генерирует HTML-код страницы, страница может быть отображена на устройствах с ограниченными возможностями.

  

Минусы SSR

  

1. Сложность: Реализация SSR требует дополнительных усилий и знаний.

2. Нагрузка на сервер: Генерация HTML-кодов страницы на стороне сервера может увеличить нагрузку на сервер.

3. Ограничения: SSR может ограничить возможности использования клиентских скриптов и библиотек.

  

Предназначение SSR

  

SSR предназначен для использования в следующих случаях:

  

1. Веб-приложения с высоким трафиком: SSR может помочь улучшить производительность и уменьшить нагрузку на сервер.

2. Веб-приложения с требованием к SEO: SSR может помочь улучшить индексацию поисковых систем.

3. Веб-приложения с ограниченными возможностями: SSR может помочь обеспечить совместимость с устройствами с ограниченными возможностями.

------------------------------------------------------------------

Что такое DOM?

Ответ:

DOM - это программная модель, которая представляет структуру и содержимое веб-страницы в виде дерева объектов. DOM позволяет программам и скриптам взаимодействовать с веб-страницей, изменять ее содержимое и структуру.

  

Структура DOM представляет собой дерево объектов, в котором каждый узел представляет собой элемент веб-страницы, такой как HTML-тег, текст или комментарий. Каждый узел имеет следующие свойства:

------------------------------------------------------------------

У событий в браузере есть фаза всплытия и фаза захвата, можешь рассказать о разнице между ними?

Фаза захвата (capture phase):

Ответ:

 **Начинается с корневого элемента документа (document) и проходит вниз по DOM-дереву к целевому элементу, на котором произошло событие.**

 В этой фазе событие сначала обрабатывается родительскими элементами, а затем дочерними элементами.

 **Если у родительского элемента есть обработчик события, он будет вызван в этой фазе.**

  

**Фаза всплытия (bubbling phase):**

  

 Начинается с целевого элемента, на котором произошло событие, и проходит вверх по DOM-дереву к корневому элементу документа (document).

 **В этой фазе событие сначала обрабатывается целевым элементом, а затем родительскими элементами.**

 Если у родительского элемента есть обработчик события, он будет вызван в этой фазе.

  

Разница между этими фазами заключается в порядке, в котором событие обрабатывается элементами DOM-дерева. В фазе захвата событие обрабатывается сначала родительскими элементами, а затем дочерними элементами, а в фазе всплытия событие обрабатывается сначала целевым элементом, а затем родительскими элементами.

------------------------------------------------------------------

Что такое preventDefault, stopPropagation и stopImmediatePropagation?

Ответ:  
preventDefault() - метод, который предотвращает выполнение действия по умолчанию для события. Например, если мы хотим предотвратить отправку формы при нажатии на кнопку "Отправить", мы можем использовать preventDefault().

  

stopPropagation() - метод, который останавливает распространение события по DOM-дереву. Когда событие происходит, оно распространяется по DOM-дереву, вызывая обработчики событий на всех родительских элементах. stopPropagation() останавливает это распространение, не позволяя событию достигнуть родительских элементов.

  

stopImmediatePropagation() - метод, который останавливает распространение события по DOM-дереву и предотвращает вызов других обработчиков событий на том же элементе. Это означает, что если у элемента есть несколько обработчиков событий, stopImmediatePropagation() остановит выполнение всех остальных обработчиков.

  

input @focus="" @click=""

------------------------------------------------------------------

Можешь рассказать про событийную модель браузера? Т.е. про event loop и task queue.

  

**Вопрос 1:** Как работает event loop в браузере? Какие этапы проходит event loop при обработке событий?

  

**Ответ:** Event loop в браузере представляет собой бесконечный цикл, который обрабатывает события в очереди. Он состоит из следующих этапов:

  

1. Проверка очереди событий (event queue) на наличие новых событий.

2. Выполнение события из очереди.

3. Обновление DOM и рендеринг страницы.

4. Проверка микрозадач (microtasks) и выполнение их, если они есть.

5. Проверка макрозадач (macrotasks) и выполнение их, если они есть.

  

**Вопрос 2:** Что произойдет, если в обработчике события будет вызвана функция, которая блокирует выполнение event loop? Как это повлияет на работу приложения?

  

**Ответ:** Если в обработчике события будет вызвана функция, которая блокирует выполнение event loop, это приведет к тому, что event loop будет заблокирован до тех пор, пока функция не завершит свою работу. Это может привести к замораживанию интерфейса пользователя и невозможности обработки других событий.

  

**Вопрос 3:** Как можно использовать async/await для улучшения работы event loop в приложении? Какие преимущества дает использование async/await?

  

**Ответ:** Async/await позволяет писать асинхронный код, который не блокирует выполнение event loop. Это дает следующие преимущества:

* Улучшение производительности приложения, поскольку event loop не блокируется.

* Упрощение кода, поскольку async/await позволяет писать асинхронный код в синхронном стиле.

* Улучшение взаимодействия с пользователем, поскольку интерфейс пользователя не замораживается во время выполнения асинхронных операций.

------------------------------------------------------------------

Знаешь что такое ESLint/Prettier?

------------------------------------------------------------------

Какой git flow у вас был в команде?

------------------------------------------------------------------

Был ли опыт с гитлабом?

------------------------------------------------------------------

Где трекал задачи и с какими сервисами знаком?

------------------------------------------------------------------

Не боишься работать с консолью, знаком с ssh, bash, linux?

------------------------------------------------------------------

Попрощаться.